1. 链表是什么？
链表是物理存储上非连续、非顺序的线性数据结构，数据元素的逻辑顺序是通过链表中的指针链接实现的
链表的最小单元是「节点（Node）」，一个完整的链表，核心组成只有两部分：
一个节点分为 2 个核心区域，缺一不可：
    数据域：存放当前节点的「有效数据」（比如数字、字符串、对象等）；
    指针域（引用域）：存放一个「指针 / 引用」，指向链表中的下一个节点的内存地址；
    链表的最后一个节点，指针域的值固定为 null（空），代表链表到此结束。

2. 链表的整体结构
链表有一个「头节点（Head）」，是整个链表的入口，我们所有的操作（查找、新增、删除）都必须从「头节点」开始，顺着每个节点的指针域依次向后遍历，直到找到目标节点或走到链表末尾（null）
每个节点都是独立的，通过malloc在堆区申请内存；
节点之间没有物理关联，靠next指针维系逻辑顺序；
链表的最后一个节点的next必须赋值为NULL，作为链表的结束标志
3.传参规则？
    传一级指针，函数内修改的是结构体内部的成员，没有修改指针ps本身的地址，所以一级指针足够；
    传二级指针，函数内需要修改头指针本身的地址（比如空链表尾插、头插、头删时，头指针的指向会改变），一级指针无法修改外部变量的地址，必须传二级指针
单链表什么时候传「一级指针」？
只有只读操作、不修改头指针、不修改节点链接时，传一级指针即可
4.分类
- 单向链表
    每个节点只有 1 个指针域，只能指向「下一个节点」；
    遍历方向：只能从头到尾单向遍历，不能回头；
    尾部节点：指针域固定为 null。
- 双向链表
    每个节点有 2 个指针域：
        一个指针：指向「前驱节点」（当前节点的上一个节点）；
        一个指针：指向「后继节点」（当前节点的下一个节点）；
    遍历方向：双向可遍历，既能从头到尾，也能从尾到头；
    首尾节点：头节点的「前驱指针」为 null，尾节点的「后继指针」为 null。
访问前驱节点效率极高（时间复杂度 O (1)），弥补了单链表的短板；
每个节点需要多存一个指针，占用的内存空间比单链表更大（空间换时间）。

- 循环链表
基于「单链表 / 双向链表」改造而来，核心区别是「尾部节点」；
循环链表的最后一个节点，指针域不指向 null，而是指向「链表的头节点
5.
链表（单向）	
内存存储	物理上「非连续、散落」存储	
访问方式	不支持随机访问，只能顺序遍历，查第 n 个元素 → O (n)	
插入 / 删除	操作本身 O (1)，只需改指针，无需移动元素	
内存开销	有额外开销（存储指针），按需分配，无浪费	
长度限制	理论无限制，动态扩容（按需加节点）	
适用场景	频繁执行「插入 / 删除」操作，元素个数不固定	
